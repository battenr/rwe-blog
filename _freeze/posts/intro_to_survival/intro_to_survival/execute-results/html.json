{
  "hash": "1a856438e350e7e246b3325e7dc79b97",
  "result": {
    "markdown": "---\ntitle: \"Introduction to Survival Analysis\"\nauthor: \"Ryan Batten\"\ndate: \"2022-10-24\"\ncategories: [Survival Analysis]\nbibliography: intro_to_survival.bib\ndraft: true\nformat: \n  html:\n    code-fold: true\n---\n\n\n## Survival Analysis and Halloween Candy?\n\nWhat could time-to-event analysis and Halloween candy possible have in common? Well with Halloween fast approaching, we will get to go trick or treating which means more candy! However, it seems that sometimes our candy disappears quicker after Halloween than it probably should. Why is that you may ask? Well, sometimes parents get their hands on candy and gobble it up before you can get to eat every last piece! How will we deal with this?\n\nPutting on our statistics had, one solution is to try and found out what the median time is to all of our candy being eaten and then try to make sure it's all gone by then (or if not, then our favorite candy at least!). Luck for us, there is a a database that keeps track of kids candy and whether they got to eat all their candy.\n\n## Research Question\n\nThe first part to any research project is to first define our research question. In this situation we want to know: \"What is the risk of all of my candy going missing\n\nWith Christmas approaching soon, we all want to know: what are the odds of Santa vising me before my friends? Luckily, there is a database that keeps track of all of this! So, how are we going to answer our question with Christmas fast approaching? Well, one method would be to use a linear regression, or perhaps a generalized linear model, however there is a unique component to time-to-event data: censoring.\n\n## Causal Question\n\nThe first part to any research project is to define the research question. Our research question is: \"What is the median time to getting to eat all of my candy?\". Now that we know our research question, we need to look to our handy-dandy database that has data on this.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(survival)\nlibrary(survminer)\n\nn.obs = 244\nmaxtime = 12 \n\nset.seed(20221106)\n\n# credit to post here from Tomas Bene\n\ndf <- data.frame(\n  id = sample(x = 1:n.obs, size = n.obs, replace = FALSE),\n  age = runif(n= n.obs, min = 5, max = 22),\n  sex = rbinom(n = n.obs, size = 1, prob = 0.81), # 1 = female\n  costume = sample( x = c(\"avocado\",\"bumblebee\", \"pumpkin\", \"lion\"),\n                    size = n.obs, \n                    replace = TRUE, \n                    prob = c(0.40, 0.30, 0.20, 0.10)\n  ),\n  candy_amount = runif(n = n.obs, min = 20, max = 100), # number of pieces of candy\n  candy_type = sample (x = \n                         c(\"skittles\", \"popeye sticks\", \"candy corn\", \"lemon heads\", \"M&Ms\"),  \n                       size = n.obs, \n                       replace = TRUE, \n                       prob = c(0.15, 0.30, 0.15, 0.20, 0.20)\n  ), # what is the most common type of candy you have \n  maxtime = 12 # 12 months until next Halloween\n) \n\nsurv_data <- df %>% \n  dplyr::mutate(\n    censort = maxtime*runif(n = n.obs, min = 0, max = 1),\n    hr_age = 0.5,\n    hr_sex = 0.6,\n    hr_costume = dplyr::case_when(\n      costume == \"avocado\" ~ 2.3, \n      costume == \"bumblebee\" ~ 1.4,\n      costume == \"pumpkin\" ~ 0.36,\n      costume == \"lion\" ~ 0.56 \n    ),\n    hr_candy_amount = 0.001, \n    hr_candy_type = dplyr::case_when(\n      candy_type == \"skittles\" ~ 0.8,\n      candy_type == \"popeye sticks\" ~ 0.4, \n      candy_type == \"candy corn\" ~ 0.2, \n      candy_type == \"lemon heads\" ~ 0.5, \n      candy_type == \"M&Ms\" ~ 0.9\n    ),\n    candy_num = \n      dplyr::case_when(\n        candy_type == \"skittles\" ~ 1,\n        candy_type == \"popeye sticks\" ~ 2, \n        candy_type == \"candy corn\" ~ 3, \n        candy_type == \"lemon heads\" ~ 4, \n        candy_type == \"M&Ms\" ~ 5\n      ),\n    costume_num = \n      dplyr::case_when(\n        costume == \"avocado\" ~ 1, \n        costume == \"bumblebee\" ~ 2,\n        costume == \"pumpkin\" ~ 3,\n        costume == \"lion\" ~ 4 \n      )\n    ) %>% \n  dplyr::mutate(\n    beta_age = log(hr_age),\n    beta_sex = log(hr_sex),\n    beta_costume = log(hr_costume),\n    beta_candy_amount = log(hr_candy_amount),\n    beta_candy_type = log(hr_candy_type)\n    ) %>% \n  dplyr::mutate(\n    # h = exp(beta_age*age + beta_sex*sex + beta_candy_amount*candy_amount + beta_candy_type),\n    h = exp(beta_candy_type*candy_num + beta_sex*sex + beta_costume*costume_num),\n    dt = -log(runif(n.obs))/h, # taken from above link but Tomas referred to Bender article. \n             # Bender formula for times T ~ Exponential(baseline_hazard)\n    status = dplyr::case_when(\n      dt <= censort ~ 1, \n      dt > censort ~ 0\n    ),\n             # If you don't want to simulate \n             \n    time = pmin(dt, censort) # taking minimum of calculated dt above or the censored time\n  )\n```\n:::\n\n\nOne thing we notice when we look at the data is that we aren't sure if some kids get to eat all of their candy or not. This could be due to different reasons, such as them getting sick of their candy, only having their least favorite kind left, parent's not letting them eat the rest or....the worst of all... parents eating the rest of their candy! What should we do with this partial data?\n\nOne thing we could do is to delete this partial data as missing data, however we'd lose lots of valuable information! Even though we don't know when their candy was finished, we know the last time they had *some* candy left. This is info that we can definitely use, but how should we approach it? This is where censoring comes into play.\n\n## Censoring\n\nSo what exactly is censoring? Well, it's a fancy way to deal with having partial information. For example, imagine that we know that our best friend had candy and the last day that she had some candy left but that was the last day we knew she had candy available. This type of observation is called *right censoring* [@clark2003survivalI]. Censoring could also occur where we know the event, for example when all her candy was gone, but not when she got the candy to begin with. This is called *left censoring* [@clark2003survivalI]. There is also a third type of censoring called *interval censoring* [@clark2003survivalI] *,* where the people being observed can come in and out of being observed.\n\n## Visualize, Visualize, Visualize\n\nOne of the best things to do when first inspecting any data is to plot it. Let's do that with our data\n\n\n::: {.cell}\n\n:::\n\n\n## Kaplan-Meier Plot\n\n## Statistical Methods\n\n### Cox Proportional Hazards\n\n### Kaplan Meier\n\n## Functions\n\n### Probability Density Function\n\n$$\nf(t) = \\lim_{\\triangle \\to 0}\\frac{1}{\\triangle}P(t \\leq T \\leq t + \\triangle)\n$$\n\n### Survival Function\n\nThe survival function is given by $S(t) = P(T>t)$, which is the probability that the event occurs after time t\n\n$$\nS(t) = 1 - P(T\\leq t) = 1 - F(t) = 1-\\int_{0}^{1}f(s)ds\n$$\n\nwhere F(t) is the cumulative distribution function, also referred to as the cumulative incidence function somtimes\n\n### Hazard Function\n\nThe hazard function is related to the survival function as\n\n$$\n\\lambda(t) = \\lim_{\\triangle \\to 0}\\frac{1}{\\triangle}P(t \\leq T \\leq t + \\triangle |T \\geq t)\n$$\n\nIt is important to note that $P(t \\leq T \\leq t + \\triangle | T \\geq t)$ is the probability the event has not occurred by time $t$ but then does occur in the next time interval $\\triangle$. Another way of thinking of this is the conditional probability of experiencing the event within the next $\\triangle$ time units at time $t$ given that the event has not occurred yet.\n\n$$\n\\lambda(t) = \\frac{f(t)}{S(t)} = -\\frac{d}{dt} log S(t)\n$$\n\n### Cumulative Hazard Function\n\nSimilarly, the cumulative hazard function could be defined as\n\n$$\n\\Lambda(t) = -log S(t)\n$$\n\n## Bonus!\n\n### Distribution for TTE Data\n\nEach of the four function can be used to characterize the distribution of T. For a data analysis, you can first choose some parametric distribution and then structure any of the four functions ($f(t)$, $S(t)$, $\\lambda(t), \\Lambda(t)$ )\n\n#### Exponential Distribution\n\n$$\nh_i(t) = \\lambda \\text{ exp}(X_i^T\\beta)\n$$\n\n$$\nH_i(t) = \\lambda t \\text{ exp}(X_i^T\\beta)\n$$\n\n$$\nS_i(t) = \\text {exp}(-\\lambda t \\text { exp}(X_i^T \\beta))\n$$\n\n$$\nS_i^{-1}(u) = \\frac{\\text{- log}(u)}{\\lambda \\text{ exp}(X_i^T \\beta)}\n$$\n\n#### Weibull Distribution\n\n$$\nh_i(t) = \\gamma \\lambda (t^{\\gamma-1}) \\text{ exp}(X_i^T\\beta)\n$$\n\n$$\nH_i(t) = \\lambda (t^{\\gamma}) \\text{ exp}(X_i^T\\beta)\n$$\n\n$$\nS_i(t) = \\text {exp}(-\\lambda (t^{\\gamma}) \\text { exp}(X_i^T \\beta))\n$$\n\n$$\nS_i^{-1}(u) = (\\frac{\\text{- log}(u)}{\\lambda \\text{ exp}(X_i^T \\beta)})^{\\frac{1}{\\gamma}}\n$$\n\n### \n\n#### Gompertz Distribution\n\n$$\nh_i(t) = \\lambda \\text{ exp}(\\gamma t) \\text{ exp}(X_i^T\\beta)\n$$\n\n$$\nH_i(t) = \\frac {\\lambda(\\text {exp } (\\gamma t) -1}{\\gamma} \\text{ exp}(X_i^T\\beta)\n$$\n\n$$\nS_i(t) = \\text {exp}( \\frac{(-\\lambda(exp(\\gamma t) - 1)}{\\gamma} \\text { exp}(X_i^T \\beta))\n$$\n\n$$\nS_i^{-1}(u) = \\frac{1}{\\gamma}\\text{log}[(\\frac{-\\gamma \\text{log}(u)}{\\lambda \\text{exp}(X_i^T\\beta)}) + 1]\n$$\n\n## Kaplan-Meier Estimator\n\nThe Kaplan-Meier estimator, sometimes referred to as the *life table method* can be used to estimate the survival function nonparametrically (aka without assuming anything about the underlying distribution).\n\nThe conditional probability of survival past time $t_{(k)}$, given the event had not occurred by time $t_{(k)}$ as:\n\n$$\n\\hat{P}(T>t_{(k)}|T\\geq t_{(k)} = \\frac{s_k}{n_k} = 1 - \\frac{d_k}{n_k}\n$$\n\nIf we multiply these conditional probabilities across all risk sets, we can find the Kaplan-Meier estimator of $S(t)$ :\n\n$$\n\\hat{S}_{KM}(t) = \\prod_{k:t_{(k)} \\leq t} \\frac{s_k}{n_k} = \\prod_{k:t_{(k)} \\leq t} 1- \\frac{d_k}{n_k}\n$$\n\n## \n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}